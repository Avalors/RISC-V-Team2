$version Generated by VerilatedVcd $end
$date Fri Nov 29 14:53:50 2024 $end
$timescale 1ps $end

 $scope module TOP $end
  $var wire 32 c a0 [31:0] $end
  $var wire  1 a clk $end
  $var wire  1 b rst $end
  $scope module top $end
   $var wire  3 9 ALUctrl [2:0] $end
   $var wire 32 0 ALUop1 [31:0] $end
   $var wire 32 1 ALUop2 [31:0] $end
   $var wire 32 2 ALUout [31:0] $end
   $var wire  1 6 ALUsrc $end
   $var wire  1 3 EQ $end
   $var wire 32 / ImmOp [31:0] $end
   $var wire  2 8 ImmSrc [1:0] $end
   $var wire 32 - PC [31:0] $end
   $var wire  1 7 PCsrc $end
   $var wire 32 4 RD2 [31:0] $end
   $var wire  1 5 RegWrite $end
   $var wire 32 2 WD3 [31:0] $end
   $var wire 32 c a0 [31:0] $end
   $var wire  1 a clk $end
   $var wire 32 . instr [31:0] $end
   $var wire  1 b rst $end
   $scope module ALUOperandMux $end
    $var wire 32 d DATA_WIDTH [31:0] $end
    $var wire 32 4 in0 [31:0] $end
    $var wire 32 / in1 [31:0] $end
    $var wire 32 1 out [31:0] $end
    $var wire  1 6 sel $end
   $upscope $end
   $scope module ArithmeticLogicUnit $end
    $var wire  3 9 ALUctrl [2:0] $end
    $var wire 32 0 ALUop1 [31:0] $end
    $var wire 32 1 ALUop2 [31:0] $end
    $var wire  1 3 EQ $end
    $var wire 32 2 Result [31:0] $end
   $upscope $end
   $scope module InstructionMemory $end
    $var wire 32 d ADDRESS_WIDTH [31:0] $end
    $var wire 32 e DATA_WIDTH [31:0] $end
    $var wire 32 - addr [31:0] $end
    $var wire 32 . instr [31:0] $end
    $var wire 32 # machine_code[0] [31:0] $end
    $var wire 32 $ machine_code[1] [31:0] $end
    $var wire 32 % machine_code[2] [31:0] $end
    $var wire 32 & machine_code[3] [31:0] $end
    $var wire 32 ' machine_code[4] [31:0] $end
    $var wire 32 ( machine_code[5] [31:0] $end
    $var wire 32 ) machine_code[6] [31:0] $end
    $scope module unnamedblk1 $end
     $var wire 32 * i [31:0] $end
    $upscope $end
    $scope module unnamedblk2 $end
     $var wire 32 + i [31:0] $end
    $upscope $end
   $upscope $end
   $scope module PC_Reg $end
    $var wire 32 / ImmOp [31:0] $end
    $var wire 32 - PC [31:0] $end
    $var wire  1 7 PCsrc $end
    $var wire 32 d WIDTH [31:0] $end
    $var wire  1 a clk $end
    $var wire  1 b rst $end
   $upscope $end
   $scope module RegFile $end
    $var wire  5 : AD1 [4:0] $end
    $var wire  5 ; AD2 [4:0] $end
    $var wire  5 < AD3 [4:0] $end
    $var wire 32 0 RD1 [31:0] $end
    $var wire 32 4 RD2 [31:0] $end
    $var wire 32 2 WD3 [31:0] $end
    $var wire  1 5 WE3 $end
    $var wire 32 c a0 [31:0] $end
    $var wire  1 a clk $end
    $var wire 32 = registers[0] [31:0] $end
    $var wire 32 G registers[10] [31:0] $end
    $var wire 32 H registers[11] [31:0] $end
    $var wire 32 I registers[12] [31:0] $end
    $var wire 32 J registers[13] [31:0] $end
    $var wire 32 K registers[14] [31:0] $end
    $var wire 32 L registers[15] [31:0] $end
    $var wire 32 M registers[16] [31:0] $end
    $var wire 32 N registers[17] [31:0] $end
    $var wire 32 O registers[18] [31:0] $end
    $var wire 32 P registers[19] [31:0] $end
    $var wire 32 > registers[1] [31:0] $end
    $var wire 32 Q registers[20] [31:0] $end
    $var wire 32 R registers[21] [31:0] $end
    $var wire 32 S registers[22] [31:0] $end
    $var wire 32 T registers[23] [31:0] $end
    $var wire 32 U registers[24] [31:0] $end
    $var wire 32 V registers[25] [31:0] $end
    $var wire 32 W registers[26] [31:0] $end
    $var wire 32 X registers[27] [31:0] $end
    $var wire 32 Y registers[28] [31:0] $end
    $var wire 32 Z registers[29] [31:0] $end
    $var wire 32 ? registers[2] [31:0] $end
    $var wire 32 [ registers[30] [31:0] $end
    $var wire 32 \ registers[31] [31:0] $end
    $var wire 32 @ registers[3] [31:0] $end
    $var wire 32 A registers[4] [31:0] $end
    $var wire 32 B registers[5] [31:0] $end
    $var wire 32 C registers[6] [31:0] $end
    $var wire 32 D registers[7] [31:0] $end
    $var wire 32 E registers[8] [31:0] $end
    $var wire 32 F registers[9] [31:0] $end
    $var wire  1 b rst $end
    $scope module unnamedblk1 $end
     $var wire 32 , i [31:0] $end
    $upscope $end
    $scope module unnamedblk2 $end
     $var wire 32 ] i [31:0] $end
    $upscope $end
   $upscope $end
   $scope module SignExtender $end
    $var wire 32 d DATA_WIDTH [31:0] $end
    $var wire 32 / ImmOp [31:0] $end
    $var wire  2 8 ImmSrc [1:0] $end
    $var wire 32 . instr [31:0] $end
   $upscope $end
   $scope module controlunit $end
    $var wire  3 9 ALUctrl [2:0] $end
    $var wire  1 6 ALUsrc $end
    $var wire 32 d DATA_WIDTH [31:0] $end
    $var wire  1 3 EQ $end
    $var wire  2 8 ImmSrc [1:0] $end
    $var wire  1 7 PCsrc $end
    $var wire  1 5 RegWrite $end
    $var wire  3 _ funct3 [2:0] $end
    $var wire  7 ` funct7 [6:0] $end
    $var wire 32 . instr [31:0] $end
    $var wire  7 ^ op [6:0] $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
b00000000000000000000000000000000 #
b00000000000000000000000000000000 $
b00000000000000000000000000000000 %
b00000000000000000000000000000000 &
b00000000000000000000000000000000 '
b00000000000000000000000000000000 (
b00000000000000000000000000000000 )
b00000000000000000000000000000000 *
b00000000000000000000000000000000 +
b00000000000000000000000000000000 ,
b00000000000000000000000000000000 -
b00000000000000000000000000000000 .
b00000000000000000000000000000000 /
b00000000000000000000000000000000 0
b00000000000000000000000000000000 1
b00000000000000000000000000000000 2
03
b00000000000000000000000000000000 4
05
06
07
b00 8
b000 9
b00000 :
b00000 ;
b00000 <
b00000000000000000000000000000000 =
b00000000000000000000000000000000 >
b00000000000000000000000000000000 ?
b00000000000000000000000000000000 @
b00000000000000000000000000000000 A
b00000000000000000000000000000000 B
b00000000000000000000000000000000 C
b00000000000000000000000000000000 D
b00000000000000000000000000000000 E
b00000000000000000000000000000000 F
b00000000000000000000000000000000 G
b00000000000000000000000000000000 H
b00000000000000000000000000000000 I
b00000000000000000000000000000000 J
b00000000000000000000000000000000 K
b00000000000000000000000000000000 L
b00000000000000000000000000000000 M
b00000000000000000000000000000000 N
b00000000000000000000000000000000 O
b00000000000000000000000000000000 P
b00000000000000000000000000000000 Q
b00000000000000000000000000000000 R
b00000000000000000000000000000000 S
b00000000000000000000000000000000 T
b00000000000000000000000000000000 U
b00000000000000000000000000000000 V
b00000000000000000000000000000000 W
b00000000000000000000000000000000 X
b00000000000000000000000000000000 Y
b00000000000000000000000000000000 Z
b00000000000000000000000000000000 [
b00000000000000000000000000000000 \
b00000000000000000000000000000000 ]
b0000000 ^
b000 _
b0000000 `
1a
0b
b00000000000000000000000000000000 c
b00000000000000000000000000100000 d
b00000000000000000000000000001000 e
#1
b00001111111100000000001100010011 #
b00000000000000000000010100010011 $
b00000000000000000000010110010011 %
b00000000000001011000010100010011 &
b00000000000101011000010110010011 '
b11111110011001011001110011100011 (
b11111110000000110001100011100011 )
b00000000000000000000010000000000 *
b00000000000000000000000000000111 +
b00000000000000000000000000100000 ,
b00001111111100000000001100010011 .
b00000000000000000000000011111111 /
b00000000000000000000000011111111 1
b00000000000000000000000011111111 2
15
16
b11111 ;
b00110 <
b0010011 ^
b0000111 `
0a
